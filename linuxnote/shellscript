---------------------------------------------------------------------------------
					变量
---------------------------------------------------------------------------------
	局部变量
	本地变量
	环境变量
	位置参数变量
	特殊变量

数据类型：
	数字型，字符型

bash脚本中的算数运算
	note：bash中的变量的值都被视为字符串
---------------------------------------------------------------------------------
				算数运算格式
---------------------------------------------------------------------------------
	let：example sum1=2 sum2=8 let sum=$sum1+$sum2 echo $sum
	var = $[算数表达式] 
	var = $((算数表达式))
	note : man expr
	var = $(expr $ARG1 $op $ARG2)
	note:乘法符号有时候需要转义
增强型赋值：
	变量做某种算数运算后回存至次变量中
		let i=$i+#
		let i+=#
	+= , -+ ,*= ,/= , %=
	自增：
	let VAR=$[$VAR+1]
	let VAR+=1
	let VAR++
	自减：同上
---------------------------------------------------------------------------------
				条件测试
---------------------------------------------------------------------------------
	判断某需求是否满足，需要由测试机制来实现；
	如何编写测试表达式以实现所需的测试：
	１执行命令，并利用命令状态返回至来判断；
		０：成功
		１－２５５：　失败
	２测试表达式
		test EXPRESSION
			test 2>3
			echo $?
		[ EXPRESSION ]
	note : expressions 两端必须有空白字符，否则为语法错误；
bash 的测试表达式：
---------------------------------------------------------------------------------
	数值测试：
		-eq:是否等于是：　[$numb1 -eq $num2 ]
		-ne:是否不等于
		-gt:是否大于
		-ge:是否大于等于：
		-lt:是否小于：
		-le: 是否小于等于；	
---------------------------------------------------------------------------------
	字符串测试
		==:是否等于 [[tom == tom ]]
  				echo $?
		>:
		<:
		!=:
		=~：左侧的字符串是否能够被右侧的pattern所匹配：
		-z"STRING"：判断指定的字符串是否为空：空为真；
		-n"STRING":判断指定的字符串是否为不空；
	NOTE:字符串要加引用
		建议使用[[]]
---------------------------------------------------------------------------------
	文件测试：
		存在性测试
			-a filepath
			-e filepath 
				文件测存在性测试，存在为真，不存在为假；
			-b file:是否存在并且尾块设备文件：
			-c file : 是否存在着并且尾字符设备；	
			-f
			-h
			-p
			-S:是否存在并且尾套界子文件；
		文件权限测试：
			-r file
			-w file
			-x file ：是否存在并亲对当前用户可执行：
			-g file :首否存在并且拥有sgid权限；
			-u file
			-k file : 是否存在并且拥有sticky权限
		文件是否由内容：
			-s file :是否存在并且是否由内容：
		文件的时间戳测试：
			-N file ：文件自从上一次读操作后是否被修改过；
		从属关系测试：
			-O file : 当前用于是否是文件的属主：
			-G file : 当前用户是否属于文件的属组；
		双目测试:
			file1 -ef file2: file 与file2是否指向同一个文件系统的相同的inode 的硬链接；		
			file1 -nt file2 : file 是否新与file2
			file1 -ot file2 : file 是否旧与file2

---------------------------------------------------------------------------------
				脚本的状态返回值
---------------------------------------------------------------------------------
	默认是脚本中执行的最后一条命令的状态返回值：
	自定义退出状态码：
		exit [n]:n 为自己指定的状态码；
		      example:id user3 &> /dev/null && exit 0 || useradd user3
	note:shell进程遇到exit时，即会终止，因此，　整个脚本执行即结束；
---------------------------------------------------------------------------------
				脚本逻辑判断
---------------------------------------------------------------------------------
	逻辑运算：
		第一种方式：
			command1 && command 2
			command1 || command 2
			!command 
		第二种方式：
			expression1 -a expressoin2
			expression1 -o expression2
			!expression
练习：[ -z "$hostName" -o $hostName=="manjaro" ] && sudo hostname hellomanjaro 
---------------------------------------------------------------------------------
				向脚本传递参数
---------------------------------------------------------------------------------
	myscript.sh argu1,argu2,argu3
1			$1,$2,$3...
		shift num 可以清除掉前个参数（位置参数轮替）
特殊变量:$0
	 bashname $0 (获取脚本文件名）
	$#
	:脚本参数的个数
	$*:所有参数　每个变量是单独的字符串
	$@:所有参数　所有的参数当成一个整体字符串
	
---------------------------------------------------------------------------------
				if分支
---------------------------------------------------------------------------------

选择执行：
	单分支的ｉｆ语句
		if 测试条件；then
			code	
		fi
	双分支的if 语句
		if 测试条件；then 
		  	code
		else
			code 
		fi	
	多分支的if语句
		if 测试条件; then
			code 
		elif 测试条件; then
			code
		elif 测试条件；then
			code
		.
		.
		.
		else 
			code
		fi 

---------------------------------------------------------------------------------
note: bash -n 检查语法错误
	bash -x 单步执行
---------------------------------------------------------------------------------

---------------------------------------------------------------------------------
				read 
---------------------------------------------------------------------------------
read [option]...[name...]
		-p 'prompt'
		-t timeout 


---------------------------------------------------------------------------------
				case 语句
---------------------------------------------------------------------------------

case 语句的语法格式：

case $VARAIBLE in 
PAT1)
        分支１
        ;;
PAT2)
        分支２
        ;;
esac

case支持glob风格的通配符；	
	* ? []	a|b|c
    
--------

---------------------------------------------------------------------------------
				循环执行
---------------------------------------------------------------------------------
	for	while until

for 循环
	1.遍历列表
	2.控制变量

遍历列表:
	for VARAIBLE in LIST;do 
		循环体
	done
	
	进入条件:只要列表有元素,即可进入循环:
	退出条件:列表中的元素遍历完成;

list的生成方式:
	1.直接给出
	2.整数列表
		{start..end}
		seq [start [incremtal]] last
	3.返回列表的命令
	4.glob
	5.变量引用
		$@, $*

		
	
while condition;do
	循环体
	循环控制变量修正表达式
done


	进入条件:condition测试为真
]	退出条件:doncition测是为假

	
until condition;do
	循环体
	循环控制变量修正表达式
done


	进入条件:condition测试为假
	退出条件:doncition测是为真


循环控制语句
	continue : 提前结束本轮循环，直接进入下一论的条件判断；
	while condition1; do 
	cmd1
	if condition2; =then 
		continue
	fi
	cmdn
	done
while 循环的特殊用法（遍历文件的行）
#!/bin/sh
#
	while read line; do 
		userid=$(echo $line | cut -d: -f3)
		username=$(echo $line |cut -d: -f1)
		usershell=$(echo $line |cut -d: -f7)
		if [ $[$userid%2] -eq 0]; then 
			echo "$username, $userid,$usershell."
		fi
	done </etc/passwd


for 循环的特殊用法：
	for((控制变量初始化；便见判断表达式控制的修正语句；)) do 
	循环体
	done 
	
-----------------------------------------------------------------------
			sleep
-----------------------------------------------------------------------
----------------------------------------------------------------------
			function
----------------------------------------------------------------------
格式１
function f_name {
	函数体
}
格式２
f_name {
	函数体
}
函数的生命周期

其状态返回值为函数体中运行的最后一条命令的状态结果；
自定义状态返回值：　return
	return [0-255]
0:成功
１－２５５：失败；

函数返回值

	函数的执行结果返回值：
		１．使用echo或printf 命令进行输出
		2.函数提中调用的命令的执行结果；	函数的退出状态码：
		１．默认取决于函数体执行的最后一条命令的退出状态码；	
		２．ｒｅｔｕｒｎ；

函数可以接受参数：
	传递参数给函数；		
		在函数体中，可以使用$1,$2,...引用床递给函数的参数；还可以函数中使用$*,$@引用所有参数，$#引用传递的参数的个数；
		在调用函数时，在函数名后面以空白符分割给定的参数列表即可，例如，testfun arg1 arg2 arg3...

	定义局部变量的local variablename
	name=tom
	setname(){
		local name=terry
		echo $name
	}
	echo $name
函数递归（脚本很少使用递归）
	函数直接或是简介调用自身；


------------------------------------------------------------------
			array
------------------------------------------------------------------
数组名[索引]
${ARRAY_NAME[index]}
note: bash-4及之后的版本,支持自定义索引格式, 而不仅仅是0,1,2等数字

声明数组:
declare -a name : 声明索引数组
declare -A name:  声明关联数组
元素的赋值方式:
1. 一次赋值一个元素
2. 一次赋值全部元算
	array_name=("val1""val2"...)
3.只复制特定元素
	array_name=([2]="val2" [3]="val3")
4.read -a array_name

数组的长度(数组中元素的个数)
${#array_namep[*]}
${#array_namep[@]}第一个元素的长度

引用数组中的所有元素
	${array_name[*]}
	${array_name[@]}
数组元素切片:${array_name[@]:offset:number}

向非稀疏格式数组中追加元素:
	array_name[$(#array_name[*]}= val

删除数组中的元素:
	unset Array[index]
关联数组:
	declare -A array_name
		array_name=([i[index_nam1]="value1 ndex_nam2]="value2 )

bash中的字符串处理机制:
	字符串切片:
		${var:offet:number}

	基于模式的字符串切片
		${var#*word} : 其中word是指定的分隔符:功能: 自左而右,产找var变量所存储的字符串中, 第一次出现的word分隔符,删除字符串开头至此分隔符之间所有的字符
		${var##*word} : 其中word是指定的分隔符:功能: 自左而右,产找var变量所存储的字符串中, 最后一次出现的word分隔符,删除字符串开头至此分隔符之间所有的字符

		${var%word*} : 其中word是指定的分隔符:功能: 自右而左,产找var变量所存储的字符串中, 第一次出现的word分隔符,删除字符串尾部至此分隔符之间所有的字符
		${var%%word*} : 其中word是指定的分隔符:功能: 自右而左,产找var变量所存储的字符串中, 最后一次出现的word分隔符,删除字符串尾部至此分隔符之间所有的字符

bashshell 自带的查找替换功能;
	${var/pattern/substi}:仅替换第一次出现:	pattern->substi
	${var//pattern/substi}:替换所有
	${var/#pattern/substi}:查找var所表示的字符串中,行首被pattern所匹配道德字符串, 并将其替换为/substi
	${var/%pattern/substi}:查找var所表示的字符串中,行尾被pattern所匹配道德字符串, 并将其替换为/substi
	note: pattern中支持使用glob通配符

查找删除:
	${var/pattern}
	${var//pattern}
	${var/#patterh}
	${var/%patterh}

字符大小写转化:
	 ${var&&} var中所有的大写字符转化为小写

变量赋值:
	${var:-value} 如果var变量为空,或为设置,那么返回value,否则返回$var	
	${var:=value}如果var变量为空,或未设置,那么返回value,并将value赋值给var,否则返回,var变量的值;

	${var:+value}如果var变量不空,则返回value
	${var:?eroor_info}:如果var为空,或未设置,那么返回error_info为错误提示;否则则返回var值


-------------------------------------------------------------
			信号捕捉
-------------------------------------------------------------
列出信号
trap -l
kill -l
man 7 signal

trap command signals
trap 
---------------------------------------------------------------
			shell窗口化编程
---------------------------------------------------------------
bash中使用acsii颜色
	\033[31m string \033[0m 
	##m :	
		左侧#:
			3:前景色
			4:后景色
		右侧#:
			1.2.3.4.5.6.7
	#m:
		加粗 闪烁 下划线等功能
	独钟控制符号可以组合使用,彼此之间用;分开
dialog 命令可实现窗口话编程;	
	各个窗体控件使用方式;	
	如何获取用户选择或键入的内容?
	 默认, 其输出信息被定向到了错误输出流
	a=$(dialog)
	<高级bashi编程指南>





